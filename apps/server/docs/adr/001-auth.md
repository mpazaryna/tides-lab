# Architecture Decision Record: UUID-Based Authentication for MCP Server

## Status

Proposed

## Context

Our system consists of a Model Context Protocol (MCP) server running on Cloudflare Workers, accessed by both a React Native mobile application and desktop clients (such as Claude Desktop and Goose Desktop) and possibly web clients. 

Currently, we're considering authentication approaches that would:
1. Secure communication between clients and the MCP server
2. Provide a consistent authentication method across different client types
3. Minimize implementation complexity and maintenance overhead
4. Work efficiently with our Supabase authentication and Cloudflare infrastructure

## Decision

**We will use the Supabase-generated UUID as the API key for authentication across all clients.**

Instead of implementing a complex JWT-based authentication system or creating separate authentication mechanisms for different client types, we'll use the UUID generated by Supabase during user registration as the API key for all MCP server requests.

### Approach

1. When a user registers through the React Native app, Supabase assigns a UUID
2. This UUID is automatically propagated to Cloudflare KV storage via a Supabase function/webhook
3. All client applications use this UUID as an API key in the request header
4. The MCP server validates requests by checking if the provided UUID exists in Cloudflare KV

### Data Flow (Gherkin Syntax)

**Scenario: New user registration and MCP server access**
```gherkin
Given a new user signs up through the React Native app
When the user completes registration with Supabase Auth
Then Supabase generates a UUID for the user
And a Supabase function writes the UUID to Cloudflare KV storage
And the React Native app securely stores the UUID locally

Given the user wants to access the MCP server
When the React Native app makes a request to the MCP server
Then it includes the UUID as an API key in the request header
And the MCP server validates the UUID against Cloudflare KV
And if valid, the MCP server processes the request using the UUID as user identifier
```

**Scenario: Desktop client setup and authentication**
```gherkin
Given a user has registered through the React Native app
And has obtained their UUID
When the user enters their UUID in the desktop client settings
Then the desktop client stores the UUID securely
And uses it as an API key for all MCP server requests

Given the desktop client makes a request to the MCP server
When the request includes the UUID as an API key
Then the MCP server validates the UUID against Cloudflare KV
And if valid, processes the request using the UUID as user identifier
```

**Scenario: User revocation**
```gherkin
Given an administrator needs to revoke a user's access
When the administrator updates the user's record in Cloudflare KV
And sets the is_active flag to false
Then any subsequent requests with that UUID are rejected
And the user can no longer access the MCP server
```

## Technical Implementation

### Cloudflare KV Structure

```
KEY: {user_uuid}
VALUE: {
  "user_id": "{user_uuid}",
  "email": "user@example.com",
  "created_at": "2025-07-30T15:30:45Z",
  "is_active": true,
  "client_access": {
    "mobile": true,
    "claude_desktop": true,
    "goose_desktop": true
  }
}
```

### Supabase Function (Conceptual)

A Supabase Edge Function will handle propagating the UUID to Cloudflare KV storage when a new user is created.

### MCP Server Authentication (Conceptual)

The MCP server will extract the UUID from the `X-API-Key` header and validate it against Cloudflare KV storage.

## Consequences

### Positive

1. **Simplicity**: A single authentication method across all clients
2. **Reduced Complexity**: No JWT validation or complex token handling required
3. **Performance**: Fast validation with simple KV lookups
4. **Consistency**: UUID serves as both the identifier and authentication token
5. **Minimal Dependencies**: No additional libraries needed for token validation

### Negative

1. **Long-lived Credentials**: UUIDs don't expire like JWTs, requiring explicit revocation
2. **Limited Claims**: No built-in support for scopes, roles, or other claims
3. **No Signature Verification**: Cannot cryptographically verify the integrity of the token
4. **Manual Distribution**: Desktop clients require manual UUID entry

### Mitigations

1. Add support for key revocation through the `is_active` flag in Cloudflare KV
2. Implement client-specific access controls in the KV value if needed
3. Consider implementing a QR code or secure sharing mechanism for desktop clients

## Alternatives Considered

### JWT-Based Authentication

Using JWTs issued by Supabase would provide built-in expiration and signature verification but would add complexity to implementation and validation.

### Separate Auth Systems

Having different authentication mechanisms for mobile vs. desktop clients would provide more flexibility but would increase development and maintenance overhead.

### OAuth Flow for Desktop

Implementing a full OAuth flow for desktop clients would be more secure for initial authorization but would significantly increase complexity.

## Decision Outcome

The UUID-based approach provides the best balance of security, simplicity, and consistency across our system components. The reduced complexity will speed up development while still providing adequate security through proper implementation of secure storage and transport encryption.