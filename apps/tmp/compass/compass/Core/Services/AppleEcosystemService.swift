//
//  AppleEcosystemService.swift
//  compass
//
//  Created by MATTHEW PAZARYNA on 9/19/25.
//

import Foundation
import EventKit
import SwiftUI
import UIKit

@Observable
class AppleEcosystemService {
    private let eventStore = EKEventStore()

    enum ExportError: LocalizedError {
        case permissionDenied
        case exportFailed(String)

        var errorDescription: String? {
            switch self {
            case .permissionDenied:
                return "Permission denied to access Reminders"
            case .exportFailed(let reason):
                return "Export failed: \(reason)"
            }
        }
    }

    func requestRemindersAccess() async -> Bool {
        let status = EKEventStore.authorizationStatus(for: .reminder)

        switch status {
        case .authorized:
            return true
        case .notDetermined:
            do {
                let granted = try await eventStore.requestFullAccessToReminders()
                return granted
            } catch {
                return false
            }
        default:
            return false
        }
    }

    func exportToReminders(investigation: Investigation) async throws {
        guard await requestRemindersAccess() else {
            throw ExportError.permissionDenied
        }

        // Create a list for this investigation
        let reminderList = EKCalendar(for: .reminder, eventStore: eventStore)
        reminderList.title = "Compass: \(investigation.title)"
        reminderList.source = eventStore.defaultCalendarForNewReminders()?.source

        do {
            try eventStore.saveCalendar(reminderList, commit: false)

            // Extract actionable items from insights and knowledge
            let actionableItems = extractActionableItems(from: investigation)

            for item in actionableItems {
                let reminder = EKReminder(eventStore: eventStore)
                reminder.title = item.title
                reminder.notes = item.notes
                reminder.calendar = reminderList
                reminder.priority = item.priority

                try eventStore.save(reminder, commit: false)
            }

            try eventStore.commit()
        } catch {
            throw ExportError.exportFailed(error.localizedDescription)
        }
    }

    func createNotesContent(investigation: Investigation) -> String {
        let insights = investigation.insights.map { "â€¢ \($0.content)" }.joined(separator: "\n")
        let knowledge = investigation.knowledgeEntries.map { "**\($0.key)**: \($0.value)" }.joined(separator: "\n")

        return """
        # \(investigation.title)

        ## Key Insights
        \(insights.isEmpty ? "No insights captured yet." : insights)

        ## Knowledge Gathered
        \(knowledge.isEmpty ? "No knowledge entries yet." : knowledge)

        ## Next Steps
        \(extractActionableItems(from: investigation).map { "- [ ] \($0.title)" }.joined(separator: "\n"))

        ---
        *Generated by Compass on \(Date().formatted(date: .abbreviated, time: .shortened))*
        """
    }

    func openInNotes(content: String) {
        // Create URL scheme to open Notes with content
        let encodedContent = content.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
        let notesURL = "mobilenotes://new?content=\(encodedContent)"

        if let url = URL(string: notesURL) {
            if UIApplication.shared.canOpenURL(url) {
                UIApplication.shared.open(url)
            }
        }
    }

    private func extractActionableItems(from investigation: Investigation) -> [ActionableItem] {
        var items: [ActionableItem] = []

        // Extract from insights
        for insight in investigation.insights {
            if insight.content.localizedCaseInsensitiveContains("should") ||
               insight.content.localizedCaseInsensitiveContains("could") ||
               insight.content.localizedCaseInsensitiveContains("next") {
                items.append(ActionableItem(
                    title: "Follow up on: \(insight.content.prefix(50))...",
                    notes: insight.content,
                    priority: 5
                ))
            }
        }

        // Extract from knowledge entries
        for entry in investigation.knowledgeEntries {
            if entry.category == "Next Steps" || entry.category == "Actions" {
                items.append(ActionableItem(
                    title: entry.key,
                    notes: entry.value,
                    priority: 3
                ))
            }
        }

        // Default next step if none found
        if items.isEmpty {
            items.append(ActionableItem(
                title: "Review \(investigation.title) insights",
                notes: "Take time to process the insights gathered during this investigation",
                priority: 5
            ))
        }

        return items
    }
}

struct ActionableItem {
    let title: String
    let notes: String
    let priority: Int // 1-9, EventKit scale
}